<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Wood Cut Calculator — Test Page</title>
  <style>
    :root {
      --bg: #f6f7fb; --card: #fff; --text: #1f2937; --muted: #6b7280; --primary:#2563eb; --primary-600:#1d4ed8; --danger:#ef4444; --success:#16a34a; --warning:#d97706; --border:#e5e7eb; --shadow:0 8px 24px rgba(0,0,0,.08); --radius:14px;
    }
    body { margin:0; padding:24px; background:var(--bg); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    header, footer { background: linear-gradient(135deg, var(--primary), var(--primary-600)); color:#fff; padding:22px 24px; text-align:center; margin:-24px -24px 24px; box-shadow:var(--shadow); }
    main { max-width:1200px; margin:0 auto; display:grid; gap:20px; grid-template-columns: 1fr; }
    @media (min-width: 980px){ main { grid-template-columns: 420px 1fr; } }
    .card { background:var(--card); border:1px solid var(--border); border-radius:var(--radius); box-shadow:var(--shadow); padding:20px; }
    h1{margin:0 0 6px;font-size:clamp(22px,3vw,28px);} h2{margin:0 0 10px;font-size:18px;}
    textarea { width:100%; height:220px; padding:14px 12px; margin:12px 0 10px; border:1px solid var(--border); border-radius:12px; background:transparent; color:var(--text); font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:14px; outline:none; }
    textarea:focus{ box-shadow:0 0 0 3px rgba(99,102,241,.18); border-color: var(--primary-600); }
    .button-row{ display:flex; gap:10px; flex-wrap:wrap; }
    button { background:var(--primary); color:#fff; border:none; padding:10px 16px; border-radius:12px; cursor:pointer; font-size:14px; font-weight:600; box-shadow:0 6px 16px rgba(37,99,235,.25); }
    button:hover{ background:var(--primary-600);} button.secondary{ background:transparent; color:var(--text); border:1px solid var(--border); box-shadow:none; }
    .result-item { display:inline-flex; align-items:center; gap:8px; margin-right:14px; padding:4px 10px; background: rgba(99,102,241,.08); border:1px solid var(--border); border-radius:999px; font-weight:600; }
    .error { color:var(--danger); font-weight:700; margin:15px 0; }
    #liveErrors{ margin-top:8px; color:var(--danger); font-weight:600; background:rgba(239,68,68,.1); border-left:3px solid var(--danger); padding:8px 12px; border-radius:8px; font-size:14px; }
    #liveErrors ul{ margin:0; padding-left:18px; }
    .cut-table{ width:100%; border-collapse:separate; border-spacing:0; margin-top:16px; overflow:hidden; border-radius:12px; border:1px solid var(--border); }
    .cut-table th, .cut-table td { padding:12px; text-align:left; }
    .cut-table thead th{ background: linear-gradient(180deg, rgba(148,163,184,.18), rgba(148,163,184,.10)); border-bottom:1px solid var(--border); position:sticky; top:0; }
    .cut-table tr + tr td{ border-top:1px solid var(--border); }
    .efficient{ color:var(--success); font-weight:700; } .inefficient{ color:var(--warning); font-weight:700; }
    .canvas-card{ background:var(--card); border:1px solid var(--border); border-radius:16px; box-shadow:var(--shadow); padding:12px; }
  </style>
</head>
<body>
  <header>
    <h1>Wood Sheet Cut Calculator — Test</h1>
    <p>Sheet: 48" × 96"</p>
  </header>

  <main>
    <section class="card">
      <h2>Input Pieces</h2>
      <textarea id="bulkInput" placeholder="Paste cuts here (quotes optional):
10" x 48" = 9PCS
11-7/8" x 68" = 5PCS 2L1S EDGE
11-7/8" x 48" = 6PCS 2L1S EDGE
11-7/8" x 94-1/2" = 1PCS 1L EDGE
11-7/8" x 76" = 1PCS 1L EDGE
11-7/8" x 57-5/8" = 1PCS 1L EDGE
11-7/8" x 36" = 1PCS 1L EDGE"></textarea>
      <div id="liveErrors"></div>
      <label style="display:block; margin:10px 0; user-select:none;">
        <input type="checkbox" id="conservativeToggle" checked />
        Conservative Mode (easier workflow; may use 1 extra sheet)
      </label>
      <div class="button-row">
        <button onclick="processInput()">Calculate</button>
        <button class="secondary" onclick="clearAll()">Clear</button>
        <button class="secondary" onclick="useExample()">Use Example</button>
      </div>
    </section>

    <section class="card">
      <h2>Results</h2>
      <div id="results"></div>
      <div id="errors" class="error"></div>
      <div id="cutDetails"></div>
    </section>
  </main>

  <footer>
    <p>Test build — inline HTML/JS</p>
  </footer>

<script>
// ==============================
// Config
// ==============================
const config = { sheetWidth: 48, sheetHeight: 96, stripModeAuto: true, stripWidthTolerance: 1/32, efficientDims: [47.875, 48, 96] };

// ==============================
// App entries & helpers
// ==============================
function useExample(){
  document.getElementById('bulkInput').value = `10 x 48 = 9PCS\n11-7/8 x 68 = 5PCS 2L1S EDGE\n11-7/8 x 48 = 6PCS 2L1S EDGE\n11-7/8 x 94-1/2 = 1PCS 1L EDGE\n11-7/8 x 76 = 1PCS 1L EDGE\n11-7/8 x 57-5/8 = 1PCS 1L EDGE\n11-7/8 x 36 = 1PCS 1L EDGE`;
}
function clearAll(){ document.getElementById('bulkInput').value=''; document.getElementById('results').innerHTML=''; document.getElementById('errors').innerHTML=''; document.getElementById('cutDetails').innerHTML=''; const live=document.getElementById('liveErrors'); if(live) live.innerHTML=''; }

function processInput(){
  const conservative = document.getElementById('conservativeToggle')?.checked;
  try{
    const input = document.getElementById('bulkInput').value;
    const pieces = parseInput(input);

    const tooBig = pieces.filter(p => (p.width > config.sheetWidth && p.height > config.sheetHeight && p.width > config.sheetHeight && p.height > config.sheetWidth)).map(p => `${p.originalWidth}" x ${p.originalHeight}" (${p.qty} PCS)`);
    const validPieces = pieces.filter(p => !tooBig.includes(`${p.originalWidth}" x ${p.originalHeight}" (${p.qty} PCS)`));

    const { sheets, warnings, visuals } = chooseBestPacking(validPieces, conservative);
    displayResults(sheets, [...tooBig, ...warnings], visuals);
    addPrintButton(visuals);
  }catch(err){ console.error(err); document.getElementById('errors').innerHTML = `<div class="error">⚠️ Calculation failed: ${err.message}</div>`; }
}

// Live validation
 document.addEventListener('DOMContentLoaded', ()=>{ document.getElementById('bulkInput')?.addEventListener('input', validateLiveInput); });
 function validateLiveInput(){
  const text = document.getElementById('bulkInput').value; const lines=text.split('\n'); const warnings=[];
  lines.forEach((line,idx)=>{ const n=idx+1; const t=line.trim(); if(!t) return; const parts=t.split('='); if(parts.length<2){ warnings.push(`Line ${n}: missing '=' sign`); return; } const [dim,rest]=parts; if(!/\d[^=]*x[^=]*\d/i.test(dim)) warnings.push(`Line ${n}: invalid dimension format`); if(!/\d+\s*pcs/i.test(rest)) warnings.push(`Line ${n}: missing PCS (quantity)`); const bad=rest.match(/(\d+)\s*(edge|edges)/i); if(bad) warnings.push(`Line ${n}: malformed edge — use '1L EDGE' or '2S EDGE' instead of '${bad[0]}'`); });
  const errBox = document.getElementById('liveErrors'); errBox.innerHTML = warnings.length ? `<ul>${warnings.map(w=>`<li>❌ ${w}</li>`).join('')}</ul>` : '';
 }

// Parsing helpers
function parseInput(text){ return text.split('\n').filter(l=>l.trim()).map(line=>{ const [left,rightRaw]=line.split('='); const right=(rightRaw||'').trim(); const dim=(left||'').replace(/["']/g,'').toLowerCase(); const [wStr,hStr]=dim.split(/x/); return { originalWidth:(wStr||'0').trim(), originalHeight:(hStr||'0').trim(), width:parseFraction(wStr||'0'), height:parseFraction(hStr||'0'), qty:parseInt(((right.match(/(\d+)\s*pcs/i)||[])[1]||0),10), edges:(right.match(/(\d+)\s*(L|S)/gi)||[]).reduce((a,m)=>a+parseInt(m,10),0) }; }); }
function parseFraction(str){ if(!str) return 0; return str.split(/[- ]/).reduce((tot,part)=>{ if(part.includes('/')){ const [n,d]=part.split('/'); const num=parseFloat(n), den=parseFloat(d); if(!isNaN(num)&&!isNaN(den)&&den!==0) return tot + (num/den); return tot; } const v=parseFloat(part); return tot + (isNaN(v)?0:v); },0); }
function isEfficient(piece){ return config.efficientDims.some(dim=> Math.abs(piece.width-dim)<0.01 || Math.abs(piece.height-dim)<0.01 ); }

// Strip mode
function detectCommonWidth(pieces){ const counts=new Map(); let total=0; for(const p of pieces){ total+=p.qty; const rounded=Math.round(p.width/config.stripWidthTolerance)*config.stripWidthTolerance; const key=rounded.toFixed(4); counts.set(key,(counts.get(key)||0)+p.qty); } let bestKey=null,best=0; for(const [k,c] of counts){ if(c>best){best=c;bestKey=k;} } return { commonWidth: bestKey?parseFloat(bestKey):null, ratio: total? best/total : 0 } }

function packSheetsStripMode(pieces){ const {commonWidth, ratio}=detectCommonWidth(pieces); if(!commonWidth || !config.stripModeAuto || ratio<0.7) return null; const tol=config.stripWidthTolerance+1e-6; const strip=[], other=[]; for(const p of pieces){ const isStrip=Math.abs(p.width-commonWidth)<=tol; if(isStrip){ for(let i=0;i<p.qty;i++) strip.push({...p}); } else { other.push({...p}); } }
 if(!strip.length) return null; const sample=strip[0]; const isHorizontal = sample.width < sample.height; const stripDim = isHorizontal ? sample.width : sample.height; const longDim = it => isHorizontal ? it.height : it.width; const perSheet = Math.max(1, Math.floor(config.sheetWidth / stripDim)); strip.sort((a,b)=> longDim(b) - longDim(a));
 const sheets=[], visuals=[]; let i=0; while(i<strip.length){ const stacks=Array.from({length:perSheet},()=>({used:0,parts:[]})); for(let j=i;j<strip.length;j++){ const item=strip[j]; let placed=false; for(let s=0;s<stacks.length;s++){ const partLong=longDim(item); const stack=stacks[s]; if(stack.used + partLong <= config.sheetHeight + 1e-6){ const x=s*stripDim, y=stack.used; const boxW=isHorizontal?stripDim:item.width; const boxH=isHorizontal?item.height:item.width; stack.parts.push({item,x,y,width:boxW,height:boxH}); stack.used=y+partLong; [strip[j],strip[i]]=[strip[i],strip[j]]; i++; placed=true; break; } } if(i>=strip.length) break; }
 const vis=[]; const map=new Map(); stacks.forEach(st=> st.parts.forEach(p=>{ vis.push({x:p.x,y:p.y,width:p.width,height:p.height,label:`1PCS ${p.item.originalWidth}×${p.item.originalHeight}`, colorKey:`${p.item.originalWidth}x${p.item.originalHeight}`}); const key=`${p.item.originalWidth}×${p.item.originalHeight}`; const rec=map.get(key)||{piece:p.item, rotated:false, count:0}; rec.count+=1; map.set(key,rec); })); const sheetPieces=Array.from(map.values()); const cuts=sheetPieces.reduce((a,r)=>a+(isEfficient(r.piece)?r.count:r.count*2),0); const edges=sheetPieces.reduce((a,r)=>a+(r.piece.edges||0)*r.count,0); sheets.push({pieces:sheetPieces,cuts,edges}); visuals.push(vis); }
 const remaining=strip.slice(i); remaining.push(...other); return { sheets, visuals, remaining } }

// MaxRects
class MaxRectsBin { constructor(w,h){ this.binWidth=w; this.binHeight=h; this.freeRects=[{x:0,y:0,width:w,height:h}]; this.usedRects=[]; } _fits(w,h,r){ return w<=r.width && h<=r.height; } insert(w,h,allowRotate=true){ let best=null, bss=Infinity, bls=Infinity, rotated=false; for(const r of this.freeRects){ if(this._fits(w,h,r)){ const lh=Math.abs(r.width-w), lv=Math.abs(r.height-h); const ss=Math.min(lh,lv), ls=Math.max(lh,lv); if(ss<bss || (ss===bss && ls<bls)){ best={x:r.x,y:r.y,width:w,height:h}; rotated=false; bss=ss; bls=ls; } } if(allowRotate && this._fits(h,w,r)){ const lh=Math.abs(r.width-h), lv=Math.abs(r.height-w); const ss=Math.min(lh,lv), ls=Math.max(lh,lv); if(ss<bss || (ss===bss && ls<bls)){ best={x:r.x,y:r.y,width:h,height:w}; rotated=true; bss=ss; bls=ls; } } } if(!best) return null; this._place(best); return {...best, rotated}; } _place(n){ const c={x:n.x,y:n.y,width:n.width,height:n.height}; const nf=[]; for(const r of this.freeRects){ if(!this._overlaps(c,r)){ nf.push(r); continue; } this._splitFreeNode(r,c,nf); } this.freeRects=nf; this._pruneFreeList(); this.usedRects.push({...n}); } _overlaps(a,b){ return !(a.x+a.width<=b.x || a.x>=b.x+b.width || a.y+a.height<=b.y || a.y>=b.y+b.height); } _splitFreeNode(f,u,out){ if(u.y>f.y && u.y<f.y+f.height) out.push({x:f.x,y:f.y,width:f.width,height:u.y-f.y}); if(u.y+u.height<f.y+f.height) out.push({x:f.x,y:u.y+u.height,width:f.width,height:(f.y+f.height)-(u.y+u.height)}); if(u.x>f.x && u.x<f.x+f.width) out.push({x:f.x,y:Math.max(f.y,u.y),width:u.x-f.x,height:Math.min(f.y+f.height,u.y+u.height)-Math.max(f.y,u.y)}); if(u.x+u.width<f.x+f.width) out.push({x:u.x+u.width,y:Math.max(f.y,u.y),width:(f.x+f.width)-(u.x+u.width),height:Math.min(f.y+f.height,u.y+u.height)-Math.max(f.y,u.y)}); } _pruneFreeList(){ for(let i=0;i<this.freeRects.length;i++){ for(let j=i+1;j<this.freeRects.length;j++){ const a=this.freeRects[i], b=this.freeRects[j]; if(this._containedIn(a,b)){ this.freeRects.splice(i,1); i--; break; } if(this._containedIn(b,a)){ this.freeRects.splice(j,1); j--; } } } } _containedIn(a,b){ return a.x>=b.x && a.y>=b.y && a.x+a.width<=b.x+b.width && a.y+a.height<=b.y+b.height; } }

// Orchestrators
function packPureMaxRects(pieces, conservative=true){ const items=[]; pieces.forEach(p=>{ for(let i=0;i<p.qty;i++) items.push({...p}); }); items.sort((a,b)=> Math.max(b.width,b.height)-Math.max(a.width,a.height) || (b.width*b.height)-(a.width*a.height)); const sheets=[], visuals=[], warnings=[]; let idx=0; while(idx<items.length){ const bin=new MaxRectsBin(config.sheetWidth,config.sheetHeight); const placed=[]; const dims=new Set(); for(let j=idx;j<items.length;j++){ const p=items[j]; if(conservative){ const k1=`${p.originalWidth}×${p.originalHeight}`, k2=`${p.originalHeight}×${p.originalWidth}`; if(dims.size>=6 && !dims.has(k1) && !dims.has(k2)) continue; } const node=bin.insert(p.width,p.height,true); if(node){ placed.push({x:node.x,y:node.y,width:node.width,height:node.height,label:`1PCS ${p.originalWidth}×${p.originalHeight}`,colorKey:`${p.originalWidth}x${p.originalHeight}`,piece:p,rotated:!(Math.abs(node.width-p.width)<1e-4 && Math.abs(node.height-p.height)<1e-4)}); dims.add(`${p.originalWidth}×${p.originalHeight}`); [items[j],items[idx]]=[items[idx],items[j]]; idx++; } }
 if(!placed.length){ warnings.push('⚠️ Some pieces could not be placed.'); break; }
 const map=new Map(); placed.forEach(pl=>{ const key=`${pl.piece.originalWidth}×${pl.piece.originalHeight}×${pl.rotated?'R':'N'}`; const rec=map.get(key)||{piece:pl.piece, rotated:pl.rotated, count:0}; rec.count+=1; map.set(key,rec); }); const sheetPieces=Array.from(map.values()); const cuts=sheetPieces.reduce((a,r)=>a+(isEfficient(r.piece)?r.count:r.count*2),0); const edges=sheetPieces.reduce((a,r)=>a+(r.piece.edges||0)*r.count,0); sheets.push({pieces:sheetPieces,cuts,edges}); visuals.push(placed.map(pl=>({x:pl.x,y:pl.y,width:pl.width,height:pl.height,label:`1PCS ${pl.piece.originalWidth}×${pl.piece.originalHeight}`, colorKey:`${pl.piece.originalWidth}x${pl.piece.originalHeight}`}))); if(sheets.length>200){ warnings.push('⚠️ Aborting: too many sheets generated.'); break; } }
 return { sheets, warnings, visuals } }

function chooseBestPacking(pieces, conservative=true){ const A=packSheetsGuillotine(pieces, conservative); const B=packPureMaxRects(pieces, conservative); const sheetA=A.sheets.length, sheetB=B.sheets.length; if(sheetA!==sheetB) return sheetA<sheetB?A:B; const sheetArea=config.sheetWidth*config.sheetHeight; const usedArea=pieces.reduce((s,p)=>s+p.width*p.height*p.qty,0); const wasteA=sheetA*sheetArea-usedArea, wasteB=sheetB*sheetArea-usedArea; if(wasteA!==wasteB) return wasteA<wasteB?A:B; return A; }

function packSheetsGuillotine(pieces, conservative=true){ const warnings=[], visuals=[], sheets=[]; const strip=packSheetsStripMode(pieces); let remaining=[]; if(strip){ if(strip.sheets.length){ sheets.push(...strip.sheets); visuals.push(...strip.visuals); } remaining=strip.remaining; } else { remaining=[]; pieces.forEach(p=>{ for(let i=0;i<p.qty;i++) remaining.push({...p}); }); }
 if(remaining.length){ remaining.sort((a,b)=> Math.max(b.width,b.height)-Math.max(a.width,a.height) || (b.width*b.height)-(a.width*a.height)); let idx=0; while(idx<remaining.length){ const bin=new MaxRectsBin(config.sheetWidth,config.sheetHeight); const placed=[]; const dims=new Set(); for(let j=idx;j<remaining.length;j++){ const p=remaining[j]; if(conservative){ const k1=`${p.originalWidth}×${p.originalHeight}`, k2=`${p.originalHeight}×${p.originalWidth}`; if(dims.size>=6 && !dims.has(k1) && !dims.has(k2)) continue; } const node=bin.insert(p.width,p.height,true); if(node){ placed.push({x:node.x,y:node.y,width:node.width,height:node.height,label:`1PCS ${p.originalWidth}×${p.originalHeight}`, colorKey:`${p.originalWidth}x${p.originalHeight}`, piece:p, rotated:!(Math.abs(node.width-p.width)<1e-4 && Math.abs(node.height-p.height)<1e-4)}); dims.add(`${p.originalWidth}×${p.originalHeight}`); [remaining[j],remaining[idx]]=[remaining[idx],remaining[j]]; idx++; } }
 if(!placed.length){ warnings.push('⚠️ Some pieces could not be placed. Check for tight tolerances or odd sizes.'); break; }
 const map=new Map(); placed.forEach(pl=>{ const key=`${pl.piece.originalWidth}×${pl.piece.originalHeight}×${pl.rotated?'R':'N'}`; const rec=map.get(key)||{piece:pl.piece, rotated:pl.rotated, count:0}; rec.count+=1; map.set(key,rec); }); const sheetPieces=Array.from(map.values()); const cuts=sheetPieces.reduce((a,r)=>a+(isEfficient(r.piece)?r.count:r.count*2),0); const edges=sheetPieces.reduce((a,r)=>a+(r.piece.edges||0)*r.count,0); sheets.push({pieces:sheetPieces,cuts,edges}); const vis=placed.map(pl=>({x:pl.x,y:pl.y,width:pl.width,height:pl.height,label:`1PCS ${pl.piece.originalWidth}×${pl.piece.originalHeight}`, colorKey:`${pl.piece.originalWidth}x${pl.piece.originalHeight}`})); visuals.push(vis); if(sheets.length>200){ warnings.push('⚠️ Aborting: too many sheets generated.'); break; } } }
 return { sheets, warnings, visuals } }

// Rendering & Print
function displayResults(sheets, errors, visuals){ const resultsDiv=document.getElementById('results'); const errorsDiv=document.getElementById('errors'); const detailsDiv=document.getElementById('cutDetails'); resultsDiv.innerHTML=''; errorsDiv.innerHTML=''; detailsDiv.innerHTML=''; resultsDiv.innerHTML=`<div class="result-item">Total Sheets Needed: <strong>${sheets.length}</strong></div><div class="result-item">Total Cuts: <strong>${sheets.reduce((a,s)=>a+s.cuts,0)}</strong></div><div class="result-item">Total Edges: <strong>${sheets.reduce((a,s)=>a+s.edges,0)}</strong></div>`; if(errors.length>0){ errorsDiv.innerHTML=`<div class="error">⚠️ Issues Found:<ul>${errors.map(p=>`<li>${p}</li>`).join('')}</ul></div>`; }
 let tableHTML=`<table class="cut-table"><thead><tr><th>Sheet</th><th>Pieces</th><th>Cuts</th><th>Edges</th></tr></thead><tbody>`; sheets.forEach((sheet,index)=>{ tableHTML+=`<tr><td>Sheet ${index+1}</td><td>${sheet.pieces.map(p=>{ const dims=p.rotated?`${p.piece.originalHeight}\"×${p.piece.originalWidth}\"`:`${p.piece.originalWidth}\"×${p.piece.originalHeight}\"`; const edgeStr=p.piece.edges>0?` ${p.piece.edges} EDGE`:''; return `${p.count}PCS ${dims}${edgeStr} <span class="${isEfficient(p.piece)?'efficient':'inefficient'}">(${isEfficient(p.piece)?'1-cut':'2-cut'})</span>`; }).join('<br>')}</td><td>${sheet.cuts}</td><td>${sheet.edges}</td></tr>`; }); tableHTML+='</tbody></table>'; detailsDiv.innerHTML=`<h3>Cutting Plan</h3>${tableHTML}`;
 const visualWrapper=document.createElement('div'); visualWrapper.style.display='flex'; visualWrapper.style.flexWrap='wrap'; visualWrapper.style.gap='16px'; visuals.forEach((vis,index)=>{ const canvas=document.createElement('canvas'); canvas.width=300; canvas.height=600; canvas.style.border='1px solid #ccc'; canvas.style.marginBottom='10px'; canvas.title='Hover over pieces to see their size'; const ctx=canvas.getContext('2d'); ctx.fillStyle='#fff'; ctx.fillRect(0,0,canvas.width,canvas.height); const colorMap={}; const palette=['#3498db','#e74c3c','#2ecc71','#f39c12','#9b59b6','#1abc9c','#34495e','#e67e22','#7f8c8d','#d35400','#16a085','#2980b9']; let colorIndex=0; vis.forEach(box=>{ const scaleX=canvas.width/config.sheetWidth, scaleY=canvas.height/config.sheetHeight; const x=box.x*scaleX, y=box.y*scaleY, w=box.width*scaleX, h=box.height*scaleY; if(!colorMap[box.colorKey]){ colorMap[box.colorKey]=palette[colorIndex % palette.length]; colorIndex++; } ctx.fillStyle=colorMap[box.colorKey]; ctx.fillRect(x,y,w,h); ctx.strokeStyle='#000'; ctx.lineWidth=1; ctx.strokeRect(x,y,w,h); ctx.fillStyle='#000'; ctx.font='bold 9px sans-serif'; ctx.fillText(box.label, x+4, y+12); canvas.addEventListener('mousemove', e=>{ const rect=canvas.getBoundingClientRect(); const mx=e.clientX-rect.left, my=e.clientY-rect.top; const hover=vis.find(b=>{ const sx=b.x*scaleX, sy=b.y*scaleY, sw=b.width*scaleX, sh=b.height*scaleY; return mx>=sx && mx<=sx+sw && my>=sy && my<=sy+sh; }); canvas.title=hover? hover.label + ` (${hover.width}\" × ${hover.height}\")` : 'Hover over pieces to see their size'; }); }); const container=document.createElement('div'); container.className='canvas-card'; container.style.flex='1 1 45%'; container.style.minWidth='300px'; container.innerHTML=`<h4>Sheet ${index+1} Layout:</h4>`; container.appendChild(canvas); visualWrapper.appendChild(container); }); detailsDiv.appendChild(document.createElement('hr')); detailsDiv.appendChild(visualWrapper); }

function addPrintButton(visuals){ const existing=document.getElementById('printBtn'); if(existing) existing.remove(); const btn=document.createElement('button'); btn.id='printBtn'; btn.textContent='Print Layout'; btn.style.margin='10px 0'; btn.onclick=()=>{ const w=window.open('', '_blank'); w.document.write('<html><head><title>Print Layout</title></head><body style="font-family:sans-serif;">'); w.document.write('<h2>Wood Cut Sheet Layout</h2>'); const table=document.querySelector('.cut-table'); let tableHTML=''; if(table){ tableHTML='<table style="border-collapse: collapse; width: 100%; font-family: sans-serif;">' + table.innerHTML.replace(/<th>/g,'<th style="background:#f2f2f2; padding: 8px; border: 1px solid #ccc; text-align: left;">').replace(/<td>/g,'<td style="padding: 6px; border: 1px solid #ddd; vertical-align: top;">') + '</table>'; } if(tableHTML){ w.document.write('<div style="margin-bottom:20px;">'+tableHTML+'</div>'); }
 visuals.forEach((vis,i)=>{ const c=document.createElement('canvas'); c.width=350; c.height=480; const ctx=c.getContext('2d'); ctx.fillStyle='#fff'; ctx.fillRect(0,0,c.width,c.height); const sx=c.width/config.sheetWidth, sy=c.height/config.sheetHeight; const cmap={}, pal=['#3498db','#e74c3c','#2ecc71','#f39c12','#9b59b6','#1abc9c','#34495e','#e67e22']; let ci=0; vis.forEach(b=>{ if(!cmap[b.colorKey]){ cmap[b.colorKey]=pal[ci%pal.length]; ci++; } const x=b.x*sx, y=b.y*sy, w2=b.width*sx, h2=b.height*sy; ctx.fillStyle=cmap[b.colorKey]; ctx.fillRect(x,y,w2,h2); ctx.strokeStyle='#000'; ctx.lineWidth=1; ctx.strokeRect(x,y,w2,h2); ctx.fillStyle='#000'; ctx.font='9px sans-serif'; ctx.fillText(b.label, x+2, y+10); }); const url=c.toDataURL(); w.document.write(`<div style="display:inline-block; width:48%; margin:5px; border:1px solid #999; padding:10px;"><h4>Sheet ${i+1}</h4><img src="${url}" style="width:100%; border:1px solid #ccc;"></div>`); }); w.document.write('<hr style="margin:20px 0; border-top: 2px dashed #ccc;">'); w.document.write('</body></html>'); w.document.close(); w.focus(); setTimeout(()=>w.print(),500); }; document.getElementById('cutDetails').prepend(btn); }
</script>
</body>
</html>
